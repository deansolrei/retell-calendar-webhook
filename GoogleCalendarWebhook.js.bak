/**
 * GoogleCalendarWebhook.js - Cleaned server file (updated)
 *
 * - Uses calendar-operations.js for scheduling logic (must exist in same folder)
 * - Adds a POST /provider_lookup endpoint that resolves provider tokens
 *   (providers.js + providers.json must exist in same folder)
 * - Provides endpoints:
 *    POST /provider_lookup -> returns provider token/display_name/calendar_id for a state+insurance
 *    POST /availability   -> returns available slots (and backward-compatible slotN_* keys)
 *    POST /book           -> creates a Google Calendar event (expects start/end ISO strings)
 * - Protects endpoints with SECRET_TOKEN via Authorization: Bearer <token>
 * - Uses a service account and domain-wide delegation to impersonate a workspace user when creating events
 *
 * Requirements:
 *  - npm packages: express, googleapis, luxon
 *  - calendar-operations.js and providers.js (+ providers.json) in same project
 *
 * Drop this file into your project and adjust any small NAME/ENV differences as needed.
 */

'use strict';

const express = require('express');
const { google } = require('googleapis');
const { DateTime } = require('luxon');
const fs = require('fs');
const path = require('path');

// helpers for provider directory (providers.js should export getProvider/findProviders)
const providers = require('./providers');

// --- START DIAGNOSTIC SNIPPET ---
// Place this block immediately before requiring calendar-operations to help debug require paths
console.log('DIAG: cwd=', process.cwd(), '__dirname=', __dirname);
const expected = path.join(__dirname, 'calendar-operations.js');
console.log('DIAG: expected module path:', expected, 'exists=', fs.existsSync(expected));
try {
  console.log('DIAG: require.resolve result:', require.resolve('./calendar-operations'));
} catch (err) {
  console.log('DIAG: require.resolve failed:', err && err.message ? err.message : err);
}
// --- END DIAGNOSTIC SNIPPET ---
const calendarOps = require('./calendar-operations');

const app = express();

// collect raw request body while still letting express.json() parse it
app.use(express.json({
  limit: '256kb',
  verify: (req, res, buf) => {
    try {
      req.rawBody = buf && buf.length ? buf.toString('utf8') : '';
    } catch (e) {
      req.rawBody = '';
    }
  }
}));

// Configuration (environment-variable overrides)
const PORT = Number(process.env.PORT || 8080);
const SECRET_TOKEN = process.env.SECRET_TOKEN || ''; // expected token (no "Bearer ")
const GOOGLE_CREDS_ENV = process.env.GOOGLE_CREDS || process.env.GCAL_KEY_JSON || null;
const GOOGLE_IMPERSONATE_USER = process.env.GOOGLE_IMPERSONATE_USER || process.env.GCAL_SUBJECT || null;

// default behavior values (fallback to calendarOps constants)
const DEFAULT_TIMEZONE = process.env.DEFAULT_TIMEZONE || calendarOps.DEFAULT_TIMEZONE;
const DEFAULT_REQUIRED_FREE_MINUTES = Number(process.env.DEFAULT_REQUIRED_FREE_MINUTES || calendarOps.DEFAULT_REQUIRED_FREE_MINUTES);
const DEFAULT_DAYS_TO_CHECK = Number(process.env.DAYS_TO_CHECK_AHEAD || 7);

// Helper: validate incoming bearer token
function checkAuthBearer(req) {
  const auth = req.headers.authorization || '';
  if (!SECRET_TOKEN) return true; // if unset, don't enforce (use cautiously)
  return auth === `Bearer ${SECRET_TOKEN}`;
}

// Utility: respond with 401 if unauthorized
function requireAuth(req, res) {
  if (!checkAuthBearer(req)) {
    res.status(401).json({ error: 'Unauthorized' });
    return false;
  }
  return true;
}

// Initialize Google Calendar client (JWT with optional impersonation)
async function getCalendarClient() {
  // Uses cached client if created already
  if (getCalendarClient._cached) return getCalendarClient._cached;

  if (!GOOGLE_CREDS_ENV) {
    throw new Error('Missing service account credentials (set GOOGLE_CREDS or GCAL_KEY_JSON env)');
  }

  let creds;
  if (typeof GOOGLE_CREDS_ENV === 'string') {
    try {
      creds = JSON.parse(GOOGLE_CREDS_ENV);
    } catch (e) {
      throw new Error('Invalid GOOGLE_CREDS/GCAL_KEY_JSON: not valid JSON');
    }
  } else {
    throw new Error('GOOGLE_CREDS env var not accessible');
  }

  const subject = GOOGLE_IMPERSONATE_USER || null;
  const jwt = new google.auth.JWT(
    creds.client_email,
    null,
    creds.private_key,
    [
      'https://www.googleapis.com/auth/calendar',
      'https://www.googleapis.com/auth/calendar.events'
    ],
    subject
  );

  await jwt.authorize();
  const calendarClient = google.calendar({ version: 'v3', auth: jwt });

  getCalendarClient._cached = calendarClient;
  return calendarClient;
}

/**
 * POST /provider_lookup
 * Request JSON:
 *   { state: "AZ", insurance: "Cigna" }
 *
 * Response:
 *   If one or more matches found: { token, display_name, calendar_id }
 *   If none found: { providers: [] }
 *
 * This endpoint resolves your provider directory (providers.json/providers.js).
 * It should be called before availability/book endpoints from Retell.
 */
app.post('/provider_lookup', async (req, res) => {
  try {
    if (!requireAuth(req, res)) return;

    const body = req.body || {};
    const state = (body.state || '').toString().trim().toUpperCase() || null;
    const insurance = (body.insurance || '').toString().trim() || null;

    const matches = providers.findProviders({ state, insurance });

    if (!matches || matches.length === 0) {
      return res.json({ providers: [] });
    }

    // Return the first / best match. If you prefer multiple, return { providers: matches }.
    const first = matches[0];
    return res.json({
      token: first.token,
      display_name: first.display_name,
      calendar_id: first.calendar_id
    });
  } catch (err) {
    console.error('provider_lookup error', err && err.stack ? err.stack : err);
    res.status(500).json({ error: 'server_error', message: 'provider lookup failed' });
  }
});

/**
 * POST /availability
 * Body:
 *   { calendar_id, date, days_to_check, user_timezone, required_free_minutes, max_slots, requested_window }
 *
 * calendar_id may be a provider token (preferred) or a direct calendar id.
 */
app.post('/availability', async (req, res) => {
  try {
    console.log('DEBUG RAW BODY:', req.rawBody || '<empty>');
    console.log('DEBUG /availability headers:', JSON.stringify(req.headers || {}));
    console.log('DEBUG /availability parsed body:', JSON.stringify(req.body || {}));

    if (!requireAuth(req, res)) return;

    const body = req.body || {};

    // Accept either a provider token or a direct calendar_id; we resolve either.
    const providerLookupId = body.calendar_id || body.calendarId || body.provider_token || body.providerToken;
    const provider = providers.getProvider(providerLookupId);
    if (!provider) {
      return res.status(400).json({ error: 'invalid_provider', message: 'Unknown provider identifier' });
    }
    // use provider.calendar_id for Google Calendar calls:
    const calendarIdToUse = provider.calendar_id;

    // requested date or today (in DEFAULT_TIMEZONE)
    const dateStr = body.date || DateTime.now().setZone(DEFAULT_TIMEZONE).toISODate();
    const daysToCheck = Number(body.days_to_check || body.daysToCheck || DEFAULT_DAYS_TO_CHECK);
    const userTimezone = body.user_timezone || body.userTimezone || null;
    const requiredFreeMinutes = Number(body.required_free_minutes || body.requiredFreeMinutes || DEFAULT_REQUIRED_FREE_MINUTES);
    const maxSlots = Number(body.max_slots || body.maxSlots || 4);

    // Normalize requested_window if it arrived as a JSON string (common when using Form mode)
    let requestedWindow = body.requested_window || body.requestedWindow || null;
    if (typeof requestedWindow === 'string') {
      try {
        requestedWindow = JSON.parse(requestedWindow);
      } catch (e) {
        requestedWindow = null;
      }
    }

    const calendar = await getCalendarClient();

    // Call calendarOps using the resolved calendarId
    // Provide requestedWindow to calendarOps if it supports it (optional)
    const slots = await calendarOps.findAvailableSlotsMultiDay(
      calendar,
      calendarIdToUse,
      dateStr,
      daysToCheck,
      {
        maxSlots,
        requiredFreeMinutes,
        userTimezone,
        requestedWindow
      }
    );

    // Build response and also include backward-compatible slotN keys used by the Retell flow
    const response = {
      provider_token: provider.token,
      provider_name: provider.display_name,
      available_slots: slots
    };

    for (let i = 0; i < Math.min(8, slots.length); i++) {
      const s = slots[i];
      const n = i + 1;
      response[`slot${n}_start_iso`] = s.start_iso_et;
      response[`slot${n}_end_iso`] = s.end_iso_et;
      response[`slot${n}_label`] = calendarOps.formatSlotLabel(s);
    }

    return res.json(response);
  } catch (err) {
    console.error('Error in /availability:', err && err.message ? err.message : err);
    return res.status(500).json({ error: 'Failed to fetch availability', details: err?.message || String(err) });
  }
});

/**
 * POST /book
 * Body (preferred):
 *   { calendar_id, start, end, attendee_name, attendee_email, send_confirmation, confirm_booking }
 *
 * calendar_id may be a provider token (preferred) or a direct calendar id.
 * confirm_booking (boolean) is recommended as an extra safety guard.
 */
app.post('/book', async (req, res) => {
  try {
    if (!requireAuth(req, res)) return;

    const body = req.body || {};

    // Resolve provider token OR calendar id
    const providerLookupId = body.calendar_id || body.calendarId;
    const provider = providers.getProvider(providerLookupId);
    if (!provider) {
      return res.status(400).json({ error: 'invalid_provider', message: 'Unknown provider identifier' });
    }
    // Use the canonical calendar id for Google API
    const calendarIdToUse = provider.calendar_id;

    // Optional require explicit confirm_booking = true to protect accidental calls
    if (body.confirm_booking === undefined || body.confirm_booking !== true) {
      // If you prefer not to require this, remove the guard. It's a safety net.
      return res.status(400).json({ error: 'missing_confirmation', message: 'Booking requires confirm_booking=true' });
    }

    let startIso = body.start || body.start_iso || null;
    let endIso = body.end || body.end_iso || null;

    // If user provided a user-local start and booked_minutes, convert to Eastern time range
    if ((!startIso || !endIso) && body.user_start_iso) {
      const bookedMinutes = Number(body.booked_minutes || body.bookedMinutes || calendarOps.MAX_BOOKED_MINUTES);
      const conv = calendarOps.convertUserSelectionToEastern(body.user_start_iso, body.user_timezone || body.userTimezone || null, bookedMinutes);
      startIso = conv.start_iso_et;
      endIso = conv.end_iso_et;
    }

    if (!startIso || !endIso) {
      return res.status(400).json({ error: 'Missing start and end. Provide start and end (ISO) or user_start_iso + booked_minutes.' });
    }

    // Validate ISO strings
    const dtStart = DateTime.fromISO(startIso);
    const dtEnd = DateTime.fromISO(endIso);
    if (!dtStart.isValid || !dtEnd.isValid) {
      return res.status(400).json({ error: 'Invalid start or end ISO format' });
    }

    // Re-check availability for the exact slot before booking (best-effort)
    const calendar = await getCalendarClient();

    // If calendarOps provides isSlotFree use it; otherwise attempt to check events in the range
    let slotFree = true;
    if (typeof calendarOps.isSlotFree === 'function') {
      try {
        slotFree = await calendarOps.isSlotFree(calendar, calendarIdToUse, startIso, endIso);
      } catch (e) {
        console.warn('isSlotFree check failed; proceeding to attempt booking', e && e.message ? e.message : e);
        slotFree = true; // best-effort: do not block on check errors
      }
    }

    if (!slotFree) {
      return res.status(409).json({ error: 'slot_unavailable', message: 'The requested time is no longer available' });
    }

    const attendeeName = body.attendee_name || body.attendeeName || body.name || null;
    const attendeeEmail = body.attendee_email || body.attendeeEmail || body.email || null;
    const sendConfirmation = (typeof body.send_confirmation !== 'undefined') ? Boolean(body.send_confirmation) : false;

    // Create event object
    const event = {
      summary: `Appointment${attendeeName ? ' with ' + attendeeName : ''}`,
      description: (body.description || '').toString().slice(0, 2000),
      start: { dateTime: startIso },
      end: { dateTime: endIso }
    };

    if (attendeeEmail) {
      event.attendees = [{ email: attendeeEmail }];
    }

    const insertParams = {
      calendarId: calendarIdToUse,
      requestBody: event
    };

    if (sendConfirmation) {
      insertParams.sendUpdates = 'all';
    }

    const insertRes = await calendar.events.insert(insertParams);
    const created = insertRes?.data || {};

    return res.json({
      success: true,
      provider_token: provider.token,
      provider_name: provider.display_name,
      event_id: created.id || null,
      event_link: created.htmlLink || null,
      summary: created.summary || event.summary,
      start: startIso,
      end: endIso,
      confirmation_sent: !!sendConfirmation
    });
  } catch (err) {
    console.error('Error in /book:', err && (err.response?.data || err.message) ? (err.response?.data || err.message) : err);
    const message = err?.response?.data || err?.message || String(err);
    if (typeof message === 'string' && message.includes('Service accounts cannot invite attendees')) {
      return res.status(400).json({ error: 'service_account_invite_restriction', message: 'Service accounts cannot invite attendees without Domain-Wide Delegation of Authority.' });
    }
    return res.status(500).json({ error: 'Failed to book appointment', details: message });
  }
});

// Health
app.get('/health', (_req, res) => res.json({ ok: true }));

// Start server
if (require.main === module) {
  app.listen(PORT, () => {
    console.log(`GoogleCalendarWebhook listening on port ${PORT}`);
  });
}

module.exports = app;